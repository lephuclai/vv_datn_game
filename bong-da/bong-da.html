<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>S√∫t lu√¢n l∆∞u ‚Äì N·ªÅn & khung th√†nh l√† ·∫£nh</title>

<link rel="stylesheet" href="base.css">
<link rel="stylesheet" href="game.css">

<style>
  #game-name{ background:#b4479c; color:#fff }
  #question{ text-align:center }
  #controls{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin:8px 0 }
  #mode-select, #nucleus-select{ font-size:14px; padding:6px 10px; border-radius:8px; } /* ‚Üê NEW: nucleus */
  #prompt{ font-size:28px; font-weight:800; margin:8px 0 0 }
  #choices{ display:flex; flex-wrap:wrap; gap:12px; justify-content:center; margin-top:12px }
  .opt{ min-width:120px; padding:14px 18px; border-radius:12px; font-size:22px; font-weight:700; color:#fff;
        cursor:pointer; user-select:none; border:0; box-shadow:0 3px 10px rgba(0,0,0,.2) }
  .opt.c1{ background:#FF3859 } .opt.c2{ background:#44A5DC }
  .opt.c3{ background:#FFC200; color:#603 } .opt.c4{ background:#65BF3B }
  #feedback{ text-align:center; font-weight:700; min-height:26px; margin-top:6px }
  #feedback.ok{ color:#2ecc71 } #feedback.no{ color:#e74c3c }
  #endbar{ display:none; text-align:center; margin-top:10px } #endbar button{ cursor:pointer }

  #board{ display:flex; justify-content:center; gap:20px; margin:8px 0; font-weight:800 }
  .scorebox{ background:#fff; border-radius:10px; padding:8px 14px; box-shadow:0 3px 8px rgba(0,0,0,.1) }

  /* ===== Pitch with background PNG that ALREADY contains the goal ===== */
  #pitch{
    position: relative;
    margin: 14px auto 0;
    width: 100%;
    max-width: 900px;
    aspect-ratio: 880 / 487;
    height: auto;
    border-radius: 14px;
    box-shadow: 0 3px 12px rgba(0,0,0,.12);
    overflow: hidden;
    background: url("bong-da-01.png") center/cover no-repeat;
  }

  .sprite{
    position:absolute;
    left: var(--x,50%);  top: var(--y,50%);
    transform: translate(-50%, -50%) var(--extra, none);
    transition: left .35s ease, top .35s ease, transform .35s ease;
    will-change: left, top, transform;
    pointer-events:none;
  }

  #striker{ width: 15%; max-width:none; }
  #keeper { width: 20%; max-width:none; }
  #ball   { width: 7%;  max-width:none; }

  #keeper{ transition: left .30s ease, top .30s ease, transform .30s ease; }
  #ball  { transition: left .55s ease, top .55s ease, transform .55s ease; }
  #striker{ transition: left .30s ease, top .30s ease, transform .30s ease, opacity .30s ease; }

  .striker-run{ --extra: translate(-50%, -50%) translate(3%, -6%) }
  .ball-spin{ --extra: translate(-50%, -50%) rotate(-18deg) }
  .keeper-dive-left { --extra: translate(-50%, -50%) rotate(10deg)  }
  .keeper-dive-right{ --extra: translate(-50%, -50%) rotate(-10deg) }
  .keeper-block     { --extra: translate(-50%, -50%) scale(1.06) }

  @media (max-width:680px){
    #pitch{ height: min(64vh, 440px) }
  }

  #goal-debug {
    position:absolute; border: 2px dashed rgba(255,255,255,.9);
    box-shadow: 0 0 0 9999px rgba(0,0,0,.08) inset;
    pointer-events:none; display:none; z-index: 2;
  }
</style>
</head>
<body>
<header>
  <div id="name">
    <div id="logo" class="scale-up">
      <a href="https://hoctiengviet.tforart.vn/home/">
        <img src="../logo.png" alt="logo">
      </a>
    </div>
  </div>
  <div id="account"></div>
</header>

<main>
  <div id="game-info">
    <div class="text"><h1 id="game-name">S√∫t lu√¢n l∆∞u</h1></div>
  </div>

  <!-- HUD -->
  <div id="hud" class="box" style="display:flex; gap:1rem; align-items:center; padding:8px 14px">
    <div>üèÜ ƒêi·ªÉm: <strong id="score">0</strong></div>
    <div>‚≠ê Li√™n ti·∫øp: <strong id="streak">0</strong></div>
    <div>üèÖ K·ª∑ l·ª•c: <strong id="best-streak">0</strong></div>
  </div>

  <div id="game">
    <div id="question" class="box">
      <div id="controls">
        <button id="play-sound" class="button btn-grey">üîä Nghe l·∫°i</button>
        <select id="mode-select" class="box">
          <option value="letters">Ch·∫ø ƒë·ªô: Ch·ªØ c√°i</option>
          <option value="vans">Ch·∫ø ƒë·ªô: V·∫ßn</option>
        </select>

        <!-- NEW: √Çm ch√≠nh filter -->
        <select id="nucleus-select" class="box" title="L·ªçc theo √¢m ch√≠nh" style="display:none"></select>

        <button id="restart-btn" class="button btn-grey">üîÅ Ch∆°i m·ªõi</button>
      </div>
      <div id="status">L∆∞·ª£t s√∫t c·ªßa <b>b√©</b></div>
      <div id="prompt"></div>
      <div id="choices"></div>
      <div id="feedback"></div>
      <div id="endbar"><button id="again-btn" class="button btn-grey">üîÅ Ch∆°i l·∫°i lo·∫°t s√∫t</button></div>
    </div>

    <div id="board">
      <div class="scorebox">‚öΩ B√©: <span id="you-goals">0</span>/<span id="you-taken">0</span></div>
      <div class="scorebox">üõ°Ô∏è ƒê·ªëi ph∆∞∆°ng: <span id="opp-goals">0</span>/<span id="opp-taken">0</span></div>
    </div>

    <!-- PITCH -->
    <div id="pitch" class="box">
      <div id="goal-debug"></div>
      <img id="keeper"  class="sprite" src="bong-da-04.png"   alt="keeper">
      <img id="ball"    class="sprite" src="bong-da-02.png"   alt="ball">
      <img id="striker" class="sprite" src="bong-da-03.png"   alt="striker">
    </div>
  </div>
</main>

<script>
/* ===================== DATA ===================== */
const LETTERS = ["a","ƒÉ","√¢","b","c","d","ƒë","e","√™","g","h","i","k","l","m","n","o","√¥","∆°","p","q","r","s","t","u","∆∞","v","x","y"];
const VANS = ["oa","oe","oi","ua","ue","ui","anh","ach","ang","ong","ung","√¢u","√¢y","√™u","i√™u","y√™u","√¥i","∆°i"]; // seed list

// Optional audio per token; TTS fallback if not provided.
const audioMap = {};

/* ================== CONFIG / STATE ================== */
const KICKS_PER_SIDE = 5;

// Baked default calibration (replace with your saved numbers to make it global)
const GOAL_RECT_DEFAULT = { x1: 26, y1: 24, x2: 74, y2: 60 };
const START = {
  striker: { x: 30, y: 70 },
  ball:    { x: 48, y: 86 }
};

let mode = "letters";         // "letters" | "vans"
let turn = "attack";          // "attack" | "defense"
let youGoals = 0, oppGoals = 0;
let youTaken = 0, oppTaken = 0;

let score = 0, streak = 0, bestStreak = Number(localStorage.getItem("hv_penalty_png_best")||0);
let answer = "";

/* ================== SPRITES (teams) ================== */
const ASSETS = {
  kid: { striker: "bong-da-03.png", keeper: "bong-da-oppo-02.png" },
  opp: { striker: "bong-da-oppo-01.png", keeper: "bong-da-04.png" }
};
[ASSETS.kid.striker, ASSETS.kid.keeper, ASSETS.opp.striker, ASSETS.opp.keeper].forEach(src=>{
  const i = new Image(); i.src = src;
});

/* ===================== ELEMENTS ===================== */
const scoreEl    = document.getElementById("score");
const streakEl   = document.getElementById("streak");
const bestEl     = document.getElementById("best-streak");
const youGoalsEl = document.getElementById("you-goals");
const oppGoalsEl = document.getElementById("opp-goals");
const youTakenEl = document.getElementById("you-taken");
const oppTakenEl = document.getElementById("opp-taken");

const statusEl   = document.getElementById("status");
const promptEl   = document.getElementById("prompt");
const choicesEl  = document.getElementById("choices");
const feedbackEl = document.getElementById("feedback");
const endbar     = document.getElementById("endbar");

const playBtn    = document.getElementById("play-sound");
const modeSel    = document.getElementById("mode-select");
const nucleusSel = document.getElementById("nucleus-select"); // ‚Üê NEW
const restartBtn = document.getElementById("restart-btn");
const againBtn   = document.getElementById("again-btn");

const pitch      = document.getElementById("pitch");
const goalDebug  = document.getElementById("goal-debug");
const keeperEl   = document.getElementById("keeper");
const ballEl     = document.getElementById("ball");
const strikerEl  = document.getElementById("striker");

/* ====================== HUD ====================== */
function updateHUD(){
  scoreEl.textContent  = String(score);
  streakEl.textContent = String(streak);
  bestEl.textContent   = String(bestStreak);
}
function updateBoard(){
  youGoalsEl.textContent = String(youGoals);
  oppGoalsEl.textContent = String(oppGoals);
  youTakenEl.textContent = String(youTaken);
  oppTakenEl.textContent = String(oppTaken);
}

/* ===================== AUDIO ===================== */
const audioCache = {};
function speakVI(text){
  const u = new SpeechSynthesisUtterance(text);
  u.lang = "vi-VN"; u.rate = 0.9;
  try{ speechSynthesis.cancel(); speechSynthesis.speak(u); }catch{}
}
function playSoundFor(token){
  const src = audioMap[token];
  if(src){
    if(!audioCache[token]){ const a=new Audio(src); a.preload="auto"; audioCache[token]=a; }
    audioCache[token].currentTime=0;
    audioCache[token].play().catch(()=>speakVI(token));
  } else {
    if(mode==="letters") speakVI(`ch·ªØ ${token}`); else speakVI(token);
  }
}

/* =============== HELPERS =============== */
function pick(arr){
  if (!arr || arr.length === 0) return null;
  return arr[Math.floor(Math.random() * arr.length)];
}

// REPLACE the old buildOptions()
function buildOptions(answer, bank, n = 4){
  // If the filtered bank is tiny, extend the pool with all v·∫ßn
  const pool = Array.from(new Set([...(bank || []), ...(vansAll || [])]));
  // We won't try to generate more options than the pool can provide
  const desired = Math.min(n, Math.max(2, pool.length));

  const set = new Set();
  if (answer != null) set.add(answer);

  let guard = 0;
  while (set.size < desired && guard < 1000){
    const cand = pick(pool);
    if (cand != null) set.add(cand);
    guard++;
  }

  const opts = [...set];

  // If for some reason we still have fewer than 2 options, fall back to letters
  if (opts.length < 2 && Array.isArray(LETTERS) && LETTERS.length){
    while (opts.length < Math.min(2, LETTERS.length) && guard < 1200){
      const cand = pick(LETTERS);
      if (cand != null && !opts.includes(cand)) opts.push(cand);
      guard++;
    }
  }

  return opts.sort(() => Math.random() - 0.5);
}


/* ========== CALIBRATION / POSITIONING ========== */
const GOAL_KEY = "hv_penalty_goal_rect";
let goalRect = JSON.parse(localStorage.getItem(GOAL_KEY) || "null") || GOAL_RECT_DEFAULT;

if (goalRect.x2 === goalRect.x1 || goalRect.y2 === goalRect.y1) {
  goalRect = { x1: 26, y1: 24, x2: 74, y2: 60 };
}

function inGoal(gx, gy){
  const x = goalRect.x1 + gx * (goalRect.x2 - goalRect.x1);
  const y = goalRect.y1 + gy * (goalRect.y2 - goalRect.y1);
  return { x, y };
}

const POS = {
  striker: { ...START.striker },
  ball:    { ...START.ball },
  keeper:  inGoal(0.5, 0.5)
};

function setSprite(el, who, x, y){
  POS[who].x = x; POS[who].y = y;
  el.style.setProperty('--x', x + '%');
  el.style.setProperty('--y', y + '%');
  el.style.removeProperty('--extra');
  el.className = el.className.replace(/\b(ball-spin|striker-run|keeper-\S+|keeper-block)\b/g,'').trim();
}

function resetSprites(){
  setSprite(strikerEl, 'striker', START.striker.x, START.striker.y);
  setSprite(ballEl,    'ball',    START.ball.x,    START.ball.y);
  const mid = inGoal(0.5, 0.5);
  setSprite(keeperEl,  'keeper',  mid.x,           mid.y);
}

function targetsFromRect(){
  return {
    left:   inGoal(0.20, 0.58),
    center: inGoal(0.50, 0.50),
    right:  inGoal(0.80, 0.42)
  };
}
let TARGETS = targetsFromRect();

const RUN_TO_BALL_OFFSET = { x: -3.0, y: -6.0 };
function strikerRun(){
  const tx = POS.ball.x + RUN_TO_BALL_OFFSET.x;
  const ty = POS.ball.y + RUN_TO_BALL_OFFSET.y;
  setSprite(strikerEl, 'striker', tx, ty);
  strikerEl.classList.add("striker-run");
}

function chooseKeeperDir(turn, correct, shotDir){
  if(shotDir === 'center') return 'center';
  if(turn === 'attack'){
    return correct ? (shotDir === 'left' ? 'right' : 'left') : shotDir;
  } else {
    return correct ? shotDir : (shotDir === 'left' ? 'right' : 'left');
  }
}

function ballTo(where){
  const t = (where==="left")?TARGETS.left : (where==="right")?TARGETS.right : TARGETS.center;
  setSprite(ballEl, 'ball', t.x, t.y);
  ballEl.classList.add("ball-spin");
}

function keeperTo(where){
  const t = where === 'left' ? TARGETS.left
        : where === 'right' ? TARGETS.right
        : TARGETS.center;
  setSprite(keeperEl, 'keeper', t.x, t.y);
  keeperEl.classList.remove('keeper-dive-left','keeper-dive-right','keeper-block');
  if(where==='left')   keeperEl.classList.add('keeper-dive-left');
  else if(where==='right') keeperEl.classList.add('keeper-dive-right');
  else keeperEl.classList.add('keeper-block');
}

/* ============== TEAM SPRITE SWITCHER ============== */
function applyTurnSprites(){
  if (turn === "attack"){
    strikerEl.src = ASSETS.kid.striker;
    keeperEl.src  = ASSETS.opp.keeper;
    strikerEl.alt = "B√© (ti·ªÅn ƒë·∫°o)";
    keeperEl.alt  = "Th·ªß m√¥n ƒë·ªëi ph∆∞∆°ng";
  } else {
    strikerEl.src = ASSETS.opp.striker;
    keeperEl.src  = ASSETS.kid.keeper;
    strikerEl.alt = "Ti·ªÅn ƒë·∫°o ƒë·ªëi ph∆∞∆°ng";
    keeperEl.alt  = "B√© (th·ªß m√¥n)";
  }
  strikerEl.onerror = ()=>{ strikerEl.src="bong-da-03.png"; };
  keeperEl.onerror  = ()=>{ keeperEl.src ="bong-da-04.png"; };
}

/* ===================== √ÇM CH√çNH FILTER (NEW) ===================== */
// 1) Detect nucleus (√¢m ch√≠nh): longer clusters first
const NUCLEI_ORDERED = [
  "i√™u","y√™u","∆∞∆°u","u√¥i","∆∞∆°i",
  "i√™ng","y√™ng","∆∞∆°ng","∆∞∆°m","∆∞∆°n","∆∞∆°t","∆∞∆°p","∆∞∆°u",
  "i√™m","i√™n","y√™n","u√¥n","u√¥ng","u√¢t","u√¢n","u√™",
  "oa","oe","uy","u√¥","i√™","y√™","∆∞a","ua",
  "ƒÉ","√¢","√™","√¥","∆°","∆∞",
  "a","e","i","o","u","y"
];
function detectNucleus(van){
  const v = van.normalize('NFC');
  for(const nuc of NUCLEI_ORDERED){ if(v.includes(nuc)) return nuc; }
  const m = v.match(/[aƒÉ√¢e√™io√¥∆°u∆∞y]/u);
  return m ? m[0] : "(kh√°c)";
}

// 2) Group v·∫ßn by raw nucleus
function buildNucleusMap(vans){
  const map = {};
  vans.forEach(v=>{
    const key = detectNucleus(v);
    (map[key] ||= []).push(v);
  });
  for(const k in map){ map[k].sort((a,b)=>a.localeCompare(b)); }
  return map;
}

// 3) Collapse raw keys to user-friendly labels
function collapseNucleusKey(key){
  if(["i√™","ia","y√™"].some(s=>key.includes(s))) return "ia/i√™";
  if(["u√¥","ua"].some(s=>key.includes(s))) return "ua/u√¥";
  if(["∆∞∆°","∆∞a"].some(s=>key.includes(s))) return "∆∞a/∆∞∆°";
  return key;
}

let vansAll = Array.from(new Set(VANS.map(v=>v.normalize('NFC'))));
let nucleusMap = buildNucleusMap(vansAll);
let activeNucleusLabel = "all";

function getActiveVanBank(){
  if(activeNucleusLabel === "all") return vansAll;
  const wanted = [];
  for(const rawKey in nucleusMap){
    if(collapseNucleusKey(rawKey) === activeNucleusLabel){
      wanted.push(...nucleusMap[rawKey]);
    }
  }
  return wanted.length ? Array.from(new Set(wanted)) : vansAll;
}

function refreshNucleusDropdown(){
  const groups = {};
  for(const rawKey in nucleusMap){
    const label = collapseNucleusKey(rawKey);
    (groups[label] ||= []).push(rawKey);
  }
  const order = ["all","a","ƒÉ","√¢","e","√™","i","ia/i√™","o","√¥","∆°","u","ua/u√¥","∆∞","∆∞a/∆∞∆°","y"];

  nucleusSel.innerHTML = "";
  const mk = (val, txt)=>{ const o=document.createElement("option"); o.value=val; o.textContent=txt; return o; };
  nucleusSel.appendChild(mk("all","√Çm ch√≠nh: T·∫•t c·∫£"));

  const labels = Array.from(new Set(order.concat(Object.keys(groups))));
  labels.forEach(lbl=>{
    if(lbl==="all") return;
    if(groups[lbl]) nucleusSel.appendChild(mk(lbl, `√Çm ch√≠nh: ${lbl}`));
  });

  nucleusSel.value = activeNucleusLabel;
  nucleusSel.style.display = (mode === "vans") ? "" : "none";
}

/* ============== QUESTIONS ============== */
function setStatus(){
  statusEl.innerHTML = (turn==="attack")
    ? 'L∆∞·ª£t s√∫t c·ªßa <b>b√©</b>'
    : 'L∆∞·ª£t s√∫t c·ªßa <b>ƒë·ªëi ph∆∞∆°ng</b> ‚Äî B√© h√£y <b>c·∫£n ph√°</b>!';
}

// REPLACE the body of newQuestion() with this safer version
function newQuestion(){
  feedbackEl.textContent = ""; feedbackEl.className = ""; endbar.style.display = "none";
  setStatus(); resetSprites(); applyTurnSprites();

  const bankRaw = (mode === "letters") ? LETTERS : getActiveVanBank();
  const bank = (bankRaw && bankRaw.length) ? bankRaw : vansAll;

  answer = pick(bank);
  if (answer == null){
    // Hard fallback: no data to ask ‚Äî show a gentle message
    promptEl.textContent = "Ch∆∞a c√≥ d·ªØ li·ªáu cho l·ª±a ch·ªçn n√†y. H√£y ch·ªçn √Çm ch√≠nh kh√°c ho·∫∑c ch·∫ø ƒë·ªô kh√°c.";
    choicesEl.innerHTML = "";
    return;
  }

  const options = buildOptions(answer, bank, 4);

  choicesEl.innerHTML = "";
  options.forEach((opt,i)=>{
    const btn = document.createElement("button");
    btn.className = `opt c${(i%4)+1}`;
    btn.textContent = opt;
    btn.onclick = ()=> checkAnswer(opt);
    choicesEl.appendChild(btn);
  });

  // Guard against undefined answer in audio
  if (answer) playSoundFor(answer);
}


function finishSeries(){
  let msg;
  if(youGoals > oppGoals){ msg="üèÜ B√© th·∫Øng lo·∫°t s√∫t!"; streak++; score++; }
  else if(youGoals < oppGoals){ msg="ƒê·ªëi ph∆∞∆°ng th·∫Øng. B√© c·ªë l√™n nh√©!"; streak = 0; }
  else { msg="H√≤a lo·∫°t s√∫t!"; }

  if(streak > bestStreak){ bestStreak = streak; localStorage.setItem("hv_penalty_png_best", String(bestStreak)); }
  updateHUD();
  feedbackEl.textContent = msg;
  feedbackEl.className = (youGoals >= oppGoals) ? "ok" : "no";
  endbar.style.display = "block";
}

function proceedOrFinish(){
  if(youTaken === KICKS_PER_SIDE && oppTaken === KICKS_PER_SIDE){
    setTimeout(finishSeries, 700);
  }else{
    setTimeout(()=>{ turn = (turn==="attack" ? "defense" : "attack"); newQuestion(); }, 700);
  }
}

/* ============== SHOT SEQUENCE ============== */
function playShot(correct){
  strikerRun();
  const dir = ['left','center','right'][Math.floor(Math.random()*3)];
  ballTo(dir);
  const kdir = chooseKeeperDir(turn, correct, dir);
  setTimeout(()=> keeperTo(kdir), 140);
}

function handleAttack(correct){
  playShot(correct);
  setTimeout(()=>{
    if(correct){ youGoals++; youTaken++; feedbackEl.textContent="Ghi b√†n! Tuy·ªát v·ªùi!"; feedbackEl.className="ok"; }
    else       { youTaken++;              feedbackEl.textContent="B·ªã c·∫£n ph√° r·ªìi!";     feedbackEl.className="no"; }
    updateBoard(); proceedOrFinish();
  }, 650);
}

function handleDefense(correct){
  playShot(correct);
  setTimeout(()=>{
    if(correct){ oppTaken++;              feedbackEl.textContent="C·∫£n ph√° th√†nh c√¥ng!"; feedbackEl.className="ok"; }
    else       { oppGoals++; oppTaken++;  feedbackEl.textContent="ƒê·ªëi ph∆∞∆°ng ghi b√†n!"; feedbackEl.className="no"; }
    updateBoard(); proceedOrFinish();
  }, 650);
}

function checkAnswer(opt){
  const correct = (opt === answer);
  if(correct){
    streak++; score++;
    if(streak > bestStreak){ bestStreak = streak; localStorage.setItem("hv_penalty_png_best", String(bestStreak)); }
  }else{ streak = 0; }
  updateHUD();
  if(turn==="attack") handleAttack(correct); else handleDefense(correct);
}

function resetSeries(){
  youGoals = 0; oppGoals = 0; youTaken = 0; oppTaken = 0; turn = "attack";
  updateBoard(); updateHUD(); feedbackEl.textContent=""; feedbackEl.className=""; endbar.style.display="none";
  newQuestion();
}

/* ============== CALIBRATION (press G) ============== */
function copyGoalCalibration() {
  const txt = JSON.stringify(goalRect);
  navigator.clipboard?.writeText(txt).catch(()=>{});
  alert("Copied goalRect:\n" + txt + "\nPaste this into GOAL_RECT_DEFAULT in your JS to make it permanent everywhere.");
}
function resetLocalCalibration(){ localStorage.removeItem(GOAL_KEY); location.reload(); }

let calibrating = false, clickStep = 0;
function renderGoalDebug(){
  goalDebug.style.display = 'block';
  goalDebug.style.left   = goalRect.x1 + '%';
  goalDebug.style.top    = goalRect.y1 + '%';
  goalDebug.style.width  = (goalRect.x2 - goalRect.x1) + '%';
  goalDebug.style.height = (goalRect.y2 - goalRect.y1) + '%';
}
function hideGoalDebug(){ goalDebug.style.display = 'none'; }

function pctFromEvent(e){
  const r = pitch.getBoundingClientRect();
  return {
    x: ((e.clientX - r.left) / r.width)  * 100,
    y: ((e.clientY - r.top)  / r.height) * 100
  };
}
window.addEventListener('keydown', (e)=>{
  if(e.key.toLowerCase() === 'g'){
    calibrating = true; clickStep = 0;
    feedbackEl.textContent = "CƒÉn ch·ªânh: b·∫•m v√†o G√ìC TR√äN-TR√ÅI c·ªßa khung th√†nh.";
    feedbackEl.className = "";
    renderGoalDebug();
  }
});
pitch.addEventListener('click', (e)=>{
  if(!calibrating) return;
  const p = pctFromEvent(e);
  if(clickStep === 0){
    goalRect.x1 = p.x; goalRect.y1 = p.y;
    clickStep = 1;
    feedbackEl.textContent = "B√¢y gi·ªù b·∫•m v√†o G√ìC D∆Ø·ªöI-PH·∫¢I c·ªßa khung th√†nh.";
    renderGoalDebug();
  } else {
    goalRect.x2 = p.x; goalRect.y2 = p.y;
    if(goalRect.x2 < goalRect.x1){ [goalRect.x1, goalRect.x2] = [goalRect.x2, goalRect.x1]; }
    if(goalRect.y2 < goalRect.y1){ [goalRect.y1, goalRect.y2] = [goalRect.y2, goalRect.y1]; }
    localStorage.setItem(GOAL_KEY, JSON.stringify(goalRect));
    TARGETS = targetsFromRect();
    calibrating = false; clickStep = 0;
    renderGoalDebug(); setTimeout(hideGoalDebug, 700);
    resetSprites();
    feedbackEl.textContent = "ƒê√£ l∆∞u khung th√†nh! (Nh·∫•n G ƒë·ªÉ ch·ªânh l·∫°i, ho·∫∑c ch·∫°y copyGoalCalibration() ƒë·ªÉ xu·∫•t s·ªë c·ªë ƒë·ªãnh)";
  }
});

/* ===================== INIT ===================== */
function init(){
  updateHUD(); updateBoard();
  renderGoalDebug(); setTimeout(hideGoalDebug, 800);

  playBtn.addEventListener("click", ()=> playSoundFor(answer));
  modeSel.addEventListener("change", e=>{
    mode = e.target.value;
    refreshNucleusDropdown();   // ‚Üê show/hide + repopulate if needed
    resetSeries();
  });
  nucleusSel.addEventListener("change", e=>{
    activeNucleusLabel = e.target.value;
    resetSeries();
  });
  restartBtn.addEventListener("click", resetSeries);
  againBtn.addEventListener("click",  resetSeries);

  document.addEventListener("click", ()=>{}, { once:true }); // mobile audio prime

  refreshNucleusDropdown();     // ‚Üê build dropdown on load
  resetSeries();
}
document.addEventListener("DOMContentLoaded", init);
</script>

</body>
</html>
