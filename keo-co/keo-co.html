<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>K√©o co ‚Äì Ch·ªØ c√°i & V·∫ßn</title>

  <link rel="stylesheet" href="base.css">
  <link rel="stylesheet" href="game.css">

  <style>
    #game-name{ background:#b4479c; color:#fff }
    #question{ text-align:center }
    #controls{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin:8px 0 }
    #mode-select, #nucleus-select{ font-size:14px; padding:6px 10px; border-radius:8px }

    #prompt{ font-size:28px; font-weight:800; margin:8px 0 0; text-align:center }
    #choices{ display:flex; flex-wrap:wrap; gap:12px; justify-content:center; margin-top:12px }
    .opt{
      min-width:120px; padding:14px 18px; border-radius:12px; font-size:22px; font-weight:700; color:#fff;
      cursor:pointer; user-select:none; border:0; box-shadow:0 3px 10px rgba(0,0,0,.2);
      transition: transform .12s ease, box-shadow .12s ease;
    }
    .opt:hover{ transform:translateY(-2px); box-shadow:0 6px 16px rgba(0,0,0,.16) }
    .opt.c1{ background:#FF3859 } .opt.c2{ background:#44A5DC }
    .opt.c3{ background:#FFC200; color:#603 } .opt.c4{ background:#65BF3B }

    #feedback{ text-align:center; font-weight:700; min-height:26px; margin-top:6px }
    #feedback.ok{ color:#2ecc71 } #feedback.no{ color:#e74c3c }

    #arena {
      position: relative; margin: 14px auto 0; max-width: 1000px; height: 280px;
      border-radius: 14px; box-shadow: 0 3px 12px rgba(0,0,0,.12);
      background-image: url("keo-co-background-01.png");
      background-repeat: no-repeat; background-position: center center; background-size: cover;
      overflow: hidden;
    }
    #center-flag{ position:absolute; left:50%; top:calc(54% - 26px); transform:translateX(-50%);
      width:16px; height:52px; background:#ff5252; border-radius:0 10px 2px 2px; box-shadow:0 2px 4px rgba(0,0,0,.2) }

    .marker{ position:absolute; top:18px; font-weight:800; color:#606060; background:#ffffffcc;
      padding:4px 8px; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,.08) }
    .marker.left{ left:10px } .marker.right{ right:10px }

    #teams-wrap{
      position:absolute; left:50%; top:16%; transform: translateX(-50%);
      transition: transform .35s ease; display:grid; place-items:center; width:80%; pointer-events:none;
    }
    #teams-img{ max-width:100%; height:auto; width: 640px; filter: drop-shadow(0 10px 12px rgba(0,0,0,.18)); }

    #endbar{ display:none; text-align:center; margin-top:10px }
    #endbar button{ cursor:pointer }

    @media (max-width:900px){ #teams-img{ width: 520px } }
    @media (max-width:700px){
      #teams-img{ width: 430px } #arena{ height:250px }
    }
    @media (max-width:520px){
      #teams-img{ width: 360px } #arena{ height:230px }
    }
  </style>
</head>
<body>
<header>
  <div id="name">
    <div id="logo" class="scale-up">
      <a href="https://hoctiengviet.tforart.vn/home/">
        <img src="../logo.png" alt="logo">
      </a>
    </div>
  </div>
  <div id="account"></div>
</header>

<main>
  <div id="game-info">
    <div class="text"><h1 id="game-name">K√©o co ‚Äì Ch·ªØ c√°i & V·∫ßn</h1></div>
  </div>

  <div id="hud" class="box" style="display:flex; gap:1rem; align-items:center; padding:8px 14px">
    <div>üèÜ ƒêi·ªÉm: <strong id="score">0</strong></div>
    <div>‚≠ê Li√™n ti·∫øp: <strong id="streak">0</strong></div>
    <div>üèÖ K·ª∑ l·ª•c: <strong id="best-streak">0</strong></div>
  </div>

  <div id="game">
    <div id="arena" class="box">
      <div class="marker left">ƒê·ªëi ph∆∞∆°ng</div>
      <div class="marker right">ƒê·ªôi b√©</div>
      <div id="teams-wrap"><img id="teams-img" src="keo-co-01.png" alt="Tug of war"></div>
    </div>

    <div id="question" class="box">
      <h2>B√© tr·∫£ l·ªùi ƒë√∫ng ƒë·ªÉ k√©o d√¢y v·ªÅ ph√≠a ƒë·ªôi m√¨nh nh√©!</h2>
      <div id="controls">
        <button id="play-sound" class="button btn-grey">üîä Nghe l·∫°i</button>

        <select id="mode-select" class="box">
          <option value="letters">Ch·∫ø ƒë·ªô: Ch·ªØ c√°i</option>
          <option value="vans">Ch·∫ø ƒë·ªô: V·∫ßn</option>
        </select>

        <!-- NEW: √Çm ch√≠nh filter (visible only in V·∫ßn mode) -->
        <select id="nucleus-select" class="box" title="L·ªçc theo √¢m ch√≠nh" style="display:none">
          <!-- options injected by JS -->
        </select>

        <button id="restart-btn" class="button btn-grey">üîÅ Ch∆°i l·∫°i</button>
      </div>

      <div id="prompt"></div>
      <div id="choices"></div>
      <div id="feedback"></div>

      <div id="endbar">
        <button id="again-btn" class="button btn-grey">üîÅ Ch∆°i l·∫°i l∆∞·ª£t k√©o</button>
      </div>
    </div>
  </div>
</main>

<script>
  /* ================= Data ================= */
  const LETTERS = ["a","ƒÉ","√¢","b","c","d","ƒë","e","√™","g","h","i","k","l","m","n","o","√¥","∆°","p","q","r","s","t","u","∆∞","v","x","y"];

  // üëâ Replace VAN_DATA with the full list later (see note below).
  const VAN_DATA = [
    // a / ƒÉ / √¢ group (examples)
    "a","ac","ach","ai","am","an","ang","anh","ao","ap","at","au","ay",
    "ƒÉc","ƒÉch","ƒÉm","ƒÉn","ƒÉng","ƒÉp","ƒÉt",
    "√¢c","√¢m","√¢n","√¢ng","√¢p","√¢t","√¢u","√¢y",
    // e / √™
    "e","em","en","eng","eo","ep","et","em","en","eo","ep","et","eng",
    "√™","√™n","√™ng","√™u","√™nh","√™t","√™m",
    // i / y (include y as vowel nucleus when present)
    "i","ia","im","in","inh","ip","it","i√™m","i√™n","i√™ng","i√™u","y√™u","y√™n","y√™ng",
    // o / √¥ / ∆°
    "o","oa","oƒÉc","oach","oƒÉn","oang","oan","oat","oay","oanh","oe","oem","oen","oeng","oi","om","on","ong","op","ot","oi","om","on","ong","op","ot",
    "√¥","√¥m","√¥n","√¥ng","√¥p","√¥t","√¥i",
    "∆°","∆°i","∆°m","∆°n","∆°p","∆°t","∆∞","∆∞∆°m","∆∞∆°n","∆∞∆°ng","∆∞∆°p","∆∞∆°t","∆∞∆°u",
    // u / ∆∞
    "u","ua","u√¢","u√¢n","u√¢ng","u√¢t","u√™","u√™n","u√™ng","u√¥i","u√¥m","u√¥ng","u·ªët","uy","uya","uy√™n","uy√™t","uy√™c","uy√™ch", "uyi","uyt",
    "ung","um","un","up","ut","ui",
    "∆∞","∆∞a","∆∞∆°i","∆∞∆°m","∆∞∆°n","∆∞∆°ng","∆∞∆°p","∆∞∆°t","∆∞∆°u","∆∞ng","∆∞m","∆∞n","∆∞t","∆∞p"
  ];

  // Optional: token -> audio file. Fallback to TTS.
  const audioMap = { /* "anh": "static/audio/anh.mp3" */ };

  /* =============== √Çm ch√≠nh detection =============== */
  // Precedence: longer vowel clusters first so "i√™" wins over just "i", etc.
  const NUCLEI_ORDERED = [
    "i√™u","y√™u","∆∞∆°u","u√¥i","∆∞∆°i",
    "i√™ng","y√™ng","∆∞∆°ng","∆∞∆°m","∆∞∆°n","∆∞∆°t","∆∞∆°p","∆∞∆°u",
    "i√™m","i√™n","y√™n","u∆°n","u√¥m","u√¥n","u√¥ng","u√¢t","u√¢n","u√™",
    "oa","oe","uy","u√¥","i√™","y√™","∆∞a","ua",
    "ƒÉ","√¢","√™","√¥","∆°","∆∞",
    "a","e","i","o","u","y"
  ];
  const NUCLEI_SIMPLE = ["a","ƒÉ","√¢","e","√™","i","o","√¥","∆°","u","∆∞","y","ia/i√™","ua/u√¥","∆∞a/∆∞∆°"];

  function detectNucleus(van){
    const v = van.normalize('NFC');
    for(const nuc of NUCLEI_ORDERED){
      if(v.includes(nuc)) return nuc;
    }
    // Fallback: first Vietnamese vowel encountered
    const m = v.match(/[aƒÉ√¢e√™io√¥∆°u∆∞y]/u);
    return m ? m[0] : "(kh√°c)";
  }

  // Build a map: nucleus -> [v·∫ßn...]
  function buildNucleusMap(vans){
    const map = {};
    vans.forEach(v=>{
      const key = detectNucleus(v);
      if(!map[key]) map[key] = [];
      map[key].push(v);
    });
    // sort each list for stable UI
    for(const k in map){ map[k].sort((a,b)=>a.localeCompare(b)); }
    return map;
  }

  // Friendly grouping for the dropdown
  function collapseNucleusKey(key){
    // Merge common diphthong spellings into one label for user:
    if(["i√™","ia","y√™"].some(s=>key.includes(s))) return "ia/i√™";
    if(["u√¥","ua"].some(s=>key.includes(s))) return "ua/u√¥";
    if(["∆∞∆°","∆∞a"].some(s=>key.includes(s))) return "∆∞a/∆∞∆°";
    return key;
  }

  /* =============== Config =============== */
  const STEPS_TO_WIN = 8;
  const MOVE_PIXELS_AT_FULL = 320;

  /* =============== State =============== */
  let mode = "letters";
  let answer = "";
  let pos = 0;
  let score = 0, streak = 0, bestStreak = Number(localStorage.getItem("hv_tug_best")||0);

  let vansAll = Array.from(new Set(VAN_DATA.map(v => v.normalize('NFC')))); // unique
  let nucleusMap = buildNucleusMap(vansAll);
  let activeNucleusLabel = "all"; // "all" or a collapsed label like "a", "ia/i√™", ...

  const promptEl   = document.getElementById("prompt");
  const choicesEl  = document.getElementById("choices");
  const feedbackEl = document.getElementById("feedback");
  const playBtn    = document.getElementById("play-sound");
  const modeSel    = document.getElementById("mode-select");
  const nucleusSel = document.getElementById("nucleus-select");
  const restartBtn = document.getElementById("restart-btn");
  const againBtn   = document.getElementById("again-btn");
  const endbar     = document.getElementById("endbar");
  const teamsWrap  = document.getElementById("teams-wrap");
  const arena      = document.getElementById("arena");

  function updateHUD(){
    document.getElementById("score").textContent = String(score);
    document.getElementById("streak").textContent = String(streak);
    document.getElementById("best-streak").textContent = String(bestStreak);
  }

  /* =============== Sound =============== */
  const audioCache = {};
  function speakVI(text){ const u=new SpeechSynthesisUtterance(text); u.lang="vi-VN"; u.rate=0.9; try{ speechSynthesis.cancel(); speechSynthesis.speak(u);}catch{} }
  function playSoundFor(token){
    const src = audioMap[token];
    if(src){
      if(!audioCache[token]){ const a=new Audio(src); a.preload="auto"; audioCache[token]=a; }
      audioCache[token].currentTime=0; audioCache[token].play().catch(()=>speakVI(token));
    } else {
      if(mode==="letters") speakVI(`ch·ªØ ${token}`); else speakVI(token);
    }
  }

  /* =============== Helpers =============== */
  function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
  function shuffled(arr){ return [...arr].sort(()=>Math.random()-0.5); }

  function computeMaxShiftPx(){
    const wrapWidth = arena.clientWidth;
    return Math.min(MOVE_PIXELS_AT_FULL, Math.max(120, (wrapWidth * 0.35)));
  }

  function updateTeamsPosition(){
    const maxShift = computeMaxShiftPx();
    const shift = (pos / STEPS_TO_WIN) * maxShift;
    teamsWrap.style.transform = `translateX(calc(-50% + ${shift}px))`;
  }

  function checkFinish(){
    if(pos >= STEPS_TO_WIN){
      feedbackEl.textContent = "üéâ ƒê·ªôi b√© k√©o th·∫Øng!";
      feedbackEl.className = "ok";
      streak++; score++; if(streak>bestStreak){ bestStreak=streak; localStorage.setItem("hv_tug_best", String(bestStreak)); }
      updateHUD(); endbar.style.display = "block"; return true;
    }
    if(pos <= -STEPS_TO_WIN){
      feedbackEl.textContent = "√îi! B·ªã k√©o v·ªÅ ph√≠a ƒë·ªëi ph∆∞∆°ng r·ªìi!";
      feedbackEl.className = "no";
      streak = 0; updateHUD();
      endbar.style.display = "block"; return true;
    }
    return false;
  }

  /* =============== Question bank (with filter) =============== */
  function getActiveVanBank(){
    if(activeNucleusLabel === "all") return vansAll;

    // Gather keys in nucleusMap that collapse to the same label
    const wanted = [];
    for(const rawKey in nucleusMap){
      if(collapseNucleusKey(rawKey) === activeNucleusLabel){
        wanted.push(...nucleusMap[rawKey]);
      }
    }
    // unique
    return Array.from(new Set(wanted));
  }

  function newQuestion(){
    endbar.style.display = "none";
    feedbackEl.textContent = ""; feedbackEl.className = "";

    const bank = (mode === "letters") ? LETTERS : getActiveVanBank();
    // Safety: if filter yields no items, fall back to all vans
    const usable = (bank.length > 0) ? bank : vansAll;

    answer = pick(usable);

    const opts = new Set([answer]);
    while(opts.size < 4) opts.add(pick(usable));
    const options = shuffled([...opts]);

    choicesEl.innerHTML = "";
    options.forEach((opt,i)=>{
      const btn = document.createElement("button");
      btn.className = `opt c${(i%4)+1}`;
      btn.textContent = opt;
      btn.onclick = () => checkAnswer(opt, btn);
      choicesEl.appendChild(btn);
    });

    playSoundFor(answer);
  }

  function checkAnswer(opt, btn){
    const correct = (opt === answer);
    if(correct){
      feedbackEl.textContent = "ƒê√∫ng r·ªìi! K√©o n√†o!";
      feedbackEl.className = "ok";
      pos = Math.min(STEPS_TO_WIN, pos + 1);
      streak++; score++; if(streak>bestStreak){ bestStreak=streak; localStorage.setItem("hv_tug_best", String(bestStreak)); }
      updateHUD();
    } else {
      feedbackEl.textContent = "Ch∆∞a ƒë√∫ng! B·ªã k√©o l·∫°i!";
      feedbackEl.className = "no";
      pos = Math.max(-STEPS_TO_WIN, pos - 1);
      streak = 0; updateHUD();
      btn.style.transform = "translateY(0) scale(0.96)";
      setTimeout(()=>btn.style.transform="", 150);
    }
    updateTeamsPosition();
    if(!checkFinish()) setTimeout(newQuestion, 500);
  }

  /* =============== UI: nucleus dropdown =============== */
  function refreshNucleusDropdown(){
    const groups = {};
    // group raw keys by collapsed label
    for(const rawKey in nucleusMap){
      const label = collapseNucleusKey(rawKey);
      (groups[label] ||= []).push(rawKey);
    }

    const order = ["all","a","ƒÉ","√¢","e","√™","i","ia/i√™","o","√¥","∆°","u","ua/u√¥","∆∞","∆∞a/∆∞∆°","y"];
    nucleusSel.innerHTML = "";
    const mk = (value, text)=>{ const o=document.createElement("option"); o.value=value; o.textContent=text; return o; };
    nucleusSel.appendChild(mk("all","√Çm ch√≠nh: T·∫•t c·∫£"));

    // add existing labels in a stable order, then any extras
    const labels = Array.from(new Set(order.concat(Object.keys(groups))));
    labels.forEach(lbl=>{
      if(lbl==="all") return;
      if(groups[lbl]) nucleusSel.appendChild(mk(lbl, `√Çm ch√≠nh: ${lbl}`));
    });

    nucleusSel.value = activeNucleusLabel;
    nucleusSel.style.display = (mode === "vans") ? "" : "none";
  }

  /* =============== Init / Reset =============== */
  function resetGame(){
    pos = 0; updateTeamsPosition();
    endbar.style.display = "none";
    newQuestion();
  }

  function init(){
    updateHUD();
    playBtn.addEventListener("click", ()=> playSoundFor(answer));
    modeSel.addEventListener("change", e=>{
      mode = e.target.value;
      refreshNucleusDropdown();
      resetGame();
    });
    nucleusSel.addEventListener("change", e=>{
      activeNucleusLabel = e.target.value;
      resetGame();
    });
    restartBtn.addEventListener("click", ()=> resetGame());
    againBtn.addEventListener("click", ()=> resetGame());
    window.addEventListener("resize", updateTeamsPosition);

    refreshNucleusDropdown();
    resetGame();
  }
  window.addEventListener("DOMContentLoaded", init);
</script>
</body>
</html>
